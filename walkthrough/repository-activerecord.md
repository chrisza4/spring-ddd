# Using Repository-ActiveRecord mixed

วิธีการก็คือเราเอาเทคโนโลยี ORM เข้าไปผสมใน Entity, Aggregrate มันซะเลย ก็คือเราทำให้ CarCollection เป็น Entity ที่บันทึกได้ผ่านเทคโนโลยี ORM ที่ชื่อว่า Hibernate ซะ (จาก CRUDRepository) เราก็ไม่ต้องมี DAO ไม่ต้องมี Mapper เยอะแล้ว ลดโค้ดไปได้เป็นจำนวนมากเลย

Notable:

- การทำงานกับ Entity, Aggregrate จำเป็นต้องรู้เรื่องฐานข้อมูลมากขึ้นเช่น Embedded คืออะไร @Id คืออะไร ทำให้มีการรวม 2 ความรู้ (หรือในแง่สวยๆ คือ 2 Concern) เข้าด้วยกัน ซึ่งถ้าไปคุยกับคนที่ซีเรียสเรื่อง Separation of Concern มากๆ เขาจะไม่โอเค
- บางครั้งเทคโนโลยีก็บังคับให้เราต้องทำอะไรที่ไม่เมคเซนส์ในโดเมนได้ เช่น Coordinate และ VehicleRegistrationId กลายเป็นว่าต้องมี Setter กับ Constructor เปล่า เพื่อให้ Hibernate สามารถบันทึกลงฐานข้อมูลได้ ทำให้โมเดลของเราเบี้ยวจากโดเมนไปประมาณนึง
- คำถามที่สำคัญเลยคือมันเบี้ยวเยอะขนาดไหน
- สิ่งที่ได้มาคือสมมติว่างานของเราต้องเพิ่มฟิลด์เงี้ย แทนที่จะต้องไปเพิ่ม 4-5 ที่แล้วต้องไม่ลืมเขียน Mapper ให้ครบ ตอนนี้พอ Entity ของ DDD เป็นอะไรที่ใช้เซฟลงฐานข้อมูลได้ตรงๆ ก็ทำให้โอกาสพลาดเรื่องพวกนี้น้อยลง
- แต่ตรงข้าม ถ้าเราทำงานใน Legacy ที่ Data Structure ในฐานข้อมูลไม่ตรงกับ Entity, Aggregrate ที่เราจะโมเดลอยู่แล้ว การที่ต้องเบ้ียวใช้ท่าประหลาดๆ เยอะแยะเต็มไปหมด (ColumnName บ้าง หรือสร้าง Relationship ประหลาดๆ บ้าง ใช้ Attribute ที่เป็นเวทย์มนตร์บ้าง ใช้ Converter ขั้นสุดบ้าง) ก็ทำให้โค้ดเราซับซ้อนและอ่านยากมาก กลายเป็นว่าคนทำงานใน Domain ต้องโหลดเรื่อง ORM, Data และโดเมนที่ซับซ้อน เข้าหัวสมองในทีเดียว
- ตรงนี้แหละที่นักออกแบบจะต้องชั่งน้ำหนักให้ดี และ DDD ไม่ได้บอกไว้ว่าคุณเบี้ยวจาก Domain ได้เยอะเท่าไหร่ DDD บอกว่าอยู่ที่วิจารณญาณของคนหน้างานครับ
